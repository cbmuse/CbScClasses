GA : Object { // Genetic Algorithm object  trp 10.13.99	var <>popSize, <>critterSize, <>critterMaxes, <>critterMins, <>lastCritter, <>scores;	var <>pop;	var <>mutationRate=0.5;	var <>lastCritter, <>lastLoserIndex, <>bestIndex;		*new { arg popSize=20, critterSize=10, critterMax=1.0, critterMin=0.0;	      		      ^super.new.init(popSize,critterSize,critterMax,critterMin);	} 		       	init { arg popSize=20, critterSize=10, critterMax=1.0, critterMin=0.0;	       	       this.popSize = popSize;	       this.critterSize = critterSize;	       	       // fill up the min, max arrays. If the critter vector is going to end up	       //	having different ranges for different values, then explicitly fill them	       // after initialization with calls like 	       //   x.critterMins = [0,-1,4, ... ]  etc...	       	       this.critterMaxes = Array.fill(critterSize, critterMax);	       this.critterMins = Array.fill(critterSize,critterMin);	       this.newPop;	       		 } 	 	 // given a critter return mutated version, w/ one locus mutated.	 getMutant { arg critter; 	 	var geneIdx, gene, outcritter;	 		 	outcritter = critter.copy;	 	geneIdx = critterSize.rand;	 	gene = (rrand((critterMins @ geneIdx),(critterMaxes @ geneIdx)));	 	outcritter.put(geneIdx,gene);	 	^outcritter;	 }	 	 // return i-th critter.	 iCritter { arg i;	 	^(pop @ i);	 }	 	 score { arg fitness;  // rate the last critter generated. If it is rated better than 	//	 the loser of the last tournament, then replace the loser with the new critter.	 	 	if( (fitness > (scores @ lastLoserIndex)),	 		{ this.scores.put(lastLoserIndex,fitness);	 		    (this.pop).put(lastLoserIndex,this.lastCritter);	 		 }	 	);	 		 }	 	 //	score every critter in the population, using sum-of-distance-squared fitness function	 scoreAll { arg target; var critSize;	 	critSize = target.size;	 	popSize.do({ arg i; var fitness, sum=0;	 		critSize.do({ arg j; var diff;						diff = target.at(j) - this.iCritter(i).at(j);						sum = diff.squared + sum						});				fitness = (critSize - sum)/critSize; 	 			this.scores.put(i,fitness); 	 		});	 }	 	 	 sumDiffSquared { arg target, critter; var fitness, sum=0, size;	 	size = target.size;		size.do({ arg i; var diff;				diff = target.at(i) - critter.at(i);				sum = diff.squared + sum				});		^fitness = (size - sum)/ size;	// returns fitness val 0.0 - 1.0	}	 	 tournament {	 	// Pick three critters from the population; breed the best two, and return	 	//	the new kid.  Save the lastLoserIndex and lastCritter.	 	var momi, dadi, loseri, tempi;	 	var f_mom, f_dad,f_loser;	 	var theKid;	 		 	momi = this.popSize.rand; f_mom = (scores @ momi);	 	dadi = this.popSize.rand;  f_dad = (scores @ dadi);	 	loseri = this.popSize.rand;  f_loser = (scores @ loseri);	 		 	if ( (f_loser > f_dad), 	 		{ tempi = loseri;  loseri = dadi;  dadi = tempi },	 		{  (if (( f_loser > f_mom),  { tempi = loseri; loseri = momi; momi = tempi;} ))  }	 	);	 		 	theKid = this.breed(momi, dadi);		if ( (1.0.rand < this.mutationRate), 	 		{  theKid = this.getMutant(theKid); } ); 		 	this.lastCritter = theKid;	 	this.lastLoserIndex = loseri;	 	^theKid;	}	 		 bestCritter { var temp=0;	 	bestIndex = 0;	 	popSize.do({ arg i;	 			if (temp < scores.at(i),{ temp = scores.at(i); bestIndex = i; })	 		});	 	^this.iCritter(bestIndex);	 } 	 newPop {  // generate an entirely new population.	 	pop = Array.fill(popSize, {this.randomCritter} );	 	scores = Array.fill(popSize, {0.5.rand} );  // assign initial scores at random, but low.	 }	 	 randomCritter { // return a new random Critter.  max	 	^rrand(critterMins, critterMaxes);	 }	 	 valuePop { arg value; 	 	pop = Array.fill(popSize,{this.valueCritter(value)} );	 	scores = Array.fill(popSize,{0.5.rand});	 }	 	 valueCritter { arg value; // return a new Critter with all the same values	 	^Array.fill(critterSize,value);	 }	 	 breed { arg i,j;  // breed critter i and j, without mutation, return a new one.	 	var  mom,dad,kid, cut;	 		 	cut = rrand(1,critterSize-1);	 	mom = this.iCritter(i);	 	dad = this.iCritter(j);	 	kid = mom.copyRange(0,cut-1) ++ dad.copyRange(cut,critterSize-1);	 	^kid;	 }	 	 popPost {  // print out the population.	 	popSize.do ( { arg i;	 				(this.pop @ i).postln;	 			   } )	 }	 				 } // GA object.